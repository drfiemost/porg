#!/bin/bash
#-----------------------------------------------------------------------
# porgball - binary package support for porg
#
# This file is part of the package porg
# Copyright (C) 2014 David Ricart
# For more information visit http://porg.sourceforge.net
#-----------------------------------------------------------------------

me=$(basename $0)

warn()			{ echo "$me: $*" >&2; }
die()			{ warn "$*"; exit 1; }
say()			{ [ "$opt_verb" ] && echo "$*"; }
do_version() 	{ porg -V | sed "s/^porg/$me/"; exit 0; }


do_help()
{
cat << EOF
$me - binary package support for porg.

Usage:
  $me [OPTIONS] [<packages>|<porgballs>]

General options:
  -t, --test           Test compressed file integrity
  -v, --verbose        Explain what is being done
  -V, --version        Display version information and exit
  -h, --help           Display this help message and exit
  
Package creation options:
  -a, --all            Create a porgball for each logged package
  -X, --exact-version  Do not expand version of packages given as arguments
  -d, --directory=DIR  Create the porgballs in DIR (default is '.')
  -g, --gzip           Compress with gzip (default)
  -b, --bzip2          Compress with bzip2
  -x, --xz             Compress with xz
  -<1..9>              Compression level (speed/quality balance)
      --fast           Like -1: Compress faster
      --best           Like -9: Compress better (default)
  -f, --force          Force overwrite of existing output files
  
Package extraction options:
  -e, --extract        Extract the porgballs given as arguments
  -d, --directory=DIR  Extract the files into root directory DIR
                       (default is '/')
  -l, --log            Log the extraction with porg

Note:
  Short options cannot be joined up; for instance: '-af' is not correct,
  type '-a -f' instead.

EOF
	exit 0
}


# Defaults

opt_prog=gzip
opt_level=-9


do_check_dir()
{
	[ -d "$1" ] || die "$1: No such directory"
	[ -w "$1" ] || die "$1: Permission denied"
}


# Extract a porgball

do_extract()
{
#XXX do not run zip and tar separately

	[ -e $1 ] || { warn "$1: No such file"; return 1; }

	case $1 in
		*.porg.tar.gz)	zprog=gzip;;
		*.porg.tar.bz2)	zprog=bzip2;;
		*.porg.tar.xz)	zprog=xz;;
		*)	warn "$1: Does not look like a porgball; skipped"
			return 1
			;;
	esac

	say "Processing $1"
		
	# Test integrity of porgball, if needed
	if [ "$opt_test" ]; then
		say "Testing integrity of $1"
		$zprog $opt_verb --test $1 || return 1;
	fi

	# Decompress porgball into a tar archive
	say "Decompressing $1"
	$zprog $opt_verb $opt_force --keep --decompress $1 || return 1

	# Extract files from the tar archive
	say "Extracting files from $tarfile"
	tarfile=$(expr $1 : '\(.*\.tar\)')
	cmd="tar -C $opt_dir -xvf $tarfile"
	if [ "$opt_log" ]; then
		porg $opt_verb -lp ${1%.porg.tar.*} -- $cmd || return 1
	else
		$cmd || return 1
	fi
	rm -f $tarfile

	return 0
}


# Create a porgball for a package logged in the porg database.

do_create()
{
	say "Processing $1"

	# Write list of files logged by the package into tmpfile.
	# By using ls, only existing files are written,
	ls $(porg -zf $1) 2>/dev/null > $tmpfile
	[ -s $tmpfile ] || { say "No files to process"; return 1; }

	# Get names of tar file and tarball

	tarfile=$(echo $opt_dir/${1}.porg.tar | tr -s /)
	case $opt_prog in
		bzip2)	suf=bz2;;
		xz)		suf=xz;;
		*)		suf=gz;;
	esac
	ball=${tarfile}.$suf

	if [ -e $ball -a -z "$opt_force" ]; then
		read -p "$me: $ball already exists; do you wish to overwrite it (y/N)? "
		[ "$REPLY" = y -o "$REPLY" = Y ] || return 1
	fi

	# Create intermediate tar archive
	say "Creating $tarfile"
	tar $opt_verb -cf $tarfile --ignore-failed-read --files-from=$tmpfile || return 1

	# Create porgball
	say "Creating $ball"
	$opt_prog -f $opt_level $opt_verb $tarfile || return 1

	# Test integrity of the created porgball, if needed
	if [ "$opt_test" ]; then
		say "Testing integrity of $ball"
		$opt_prog $opt_verb -t $ball
		return $?
	fi

	return 0
}


# Parse the command line

while [ "$1" ]; do

	case $1 in

		-V|--version)		do_version;;
		-h|--help)			do_help;;
		-t|--test)			opt_test=-t;;
		-v|--verbose)		opt_verb=-v;;
		-a|--all)			opt_all=-a;;
		-X|--exact-version) opt_exact=-X;;
		-g|--gzip)			opt_prog=gzip;;
		-b|--bzip2)			opt_prog=bzip2;;
		-x|--xz)			opt_prog=xz;;
		-[0-9])				opt_level=$1;;
		--fast)				opt_level=-1;;
		--best)				opt_level=-9;;
		-f|--force)			opt_force=-f;;
		-e|--extract)		opt_extract=1;;
		-l|--log)			opt_log=1;;

		-d|-C|--directory|--dir|--root)
			[ "$2" ] && opt_dir=$2 || die "Option '$1' requires an argument"
			shift
			;;

		--directory=*|--dir=*|--root=*)
			opt_dir=${1#*=}
			[ "$opt_dir" ] || die "Option '${1%=*}' requires an argument"
			;;

		-*)	die "$1: Unrecognized option";;
		
		*)	args="$args $1";;

	esac
	shift
done

# Extraction of porgballs

if [ "$opt_extract" ]; then

	[ "$args" ] || die "No arguments provided"

	opt_dir=${opt_dir:-/}	# default dir = /
	do_check_dir $opt_dir

	for ball in $args; do
		do_extract $ball
	done

# Creation of porgballs

else
	[ "$args" -o "$opt_all" ] || die "No arguments provided"

	opt_dir=${opt_dir:-.}	# default dir = .
	do_check_dir $opt_dir

	# Create tmpfile and assure it's removed on exit
	tmpfile=$(mktemp || echo /tmp/$me.$$)
	trap 'rm -f $tmpfile' 0

	for pkg in $(porg $opt_verb $opt_exact $opt_all $args); do
		do_create $pkg
	done
fi

exit 0

